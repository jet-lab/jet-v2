use std::{cell::RefCell, convert::TryInto, rc::Rc};

use agnostic_orderbook::state::{
    critbit::{InnerNode, LeafNode, SlabHeader},
    event_queue::{EventQueueHeader, FillEvent, OutEvent},
};
use anchor_lang::{prelude::*, solana_program::hash::hash};
use bytemuck::{CheckedBitPattern, NoUninit, Pod, Zeroable};
use num_derive::FromPrimitive;
use num_traits::FromPrimitive;

/// The tick_size used in fp32 operations on the orderbook
pub const TICK_SIZE: u64 = 1;
/// The maximum number of events the event queue can support
pub const NUM_EVENTS: u32 = 2_000;
/// Total number of orders that can fit on one side of the orderbook
pub const ORDERBOOK_LEAF_CAPACITY: u32 = 1000;
/// The length in bytes of the `bids` and `asks` bitslabs used in the agnostic orderbook
pub const ORDERBOOK_SLAB_LEN: usize = ORDERBOOK_LEAF_CAPACITY as usize
    * (LeafNode::LEN + CallbackInfo::LEN + InnerNode::LEN)
    + SlabHeader::LEN
    + LeafNode::LEN
    + CallbackInfo::LEN
    + 8;
/// The length in bytes of the `event queue` used to track unconsumed orders on the agnostic orderbook
pub const EVENT_QUEUE_LEN: usize =
    NUM_EVENTS as usize * (FillEvent::LEN + 2 * CallbackInfo::LEN) + EventQueueHeader::LEN + 8;

#[derive(AnchorSerialize, AnchorDeserialize, Clone, Copy, Debug, PartialEq, Eq, Zeroable, Pod)]
#[repr(transparent)]
pub struct OrderTag([u8; 16]);

impl OrderTag {
    /// To generate an OrderTag, the program takes the sha256 hash of the orderbook user account
    /// and bond manager pubkeys, a nonce tracked by the orderbook user account, and drops the
    /// last 16 bytes to create a 16-byte array
    pub fn generate(bond_manager_key_bytes: &[u8], user_key_bytes: &[u8], nonce: u64) -> OrderTag {
        let nonce_bytes = bytemuck::bytes_of(&nonce);
        let bytes: &[u8] = &[bond_manager_key_bytes, user_key_bytes, nonce_bytes].concat();
        let hash: [u8; 32] = hash(bytes).to_bytes();
        let tag_bytes: &[u8; 16] = &hash[..16].try_into().unwrap();

        OrderTag(*tag_bytes)
    }

    pub fn bytes(&self) -> &[u8; 16] {
        &self.0
    }
}

/// The CallbackInfo is information about an order that is stored in the Event Queue
/// used to manage order metadata
#[derive(Clone, Copy, Debug, PartialEq, Eq, Zeroable, Pod)]
#[repr(C)]
pub struct CallbackInfo {
    /// The order tag is generated by the program when submitting orders to the book
    /// Used to seed and track PDAs such as `Obligation`
    pub order_tag: OrderTag,
    /// Depending on order type, this is a pubkey of a `MarginUser`, or a regular signer
    pub account_key: [u8; 32],
    /// A wallet for bond tickets or underlying tokens, depending on order type
    pub user_vault: [u8; 32],
    /// Pubkey of the account that will recieve the event information
    pub adapter_account_key: [u8; 32],
    /// configuration used by callback execution
    pub flags: CallbackFlags,
    _reserved: [u8; 14],
}

impl CallbackInfo {
    pub const LEN: usize = std::mem::size_of::<Self>();
    pub fn new(
        bond_manager_key: Pubkey,
        account_key: Pubkey,
        user_vault: Pubkey,
        adapter: Pubkey,
        flags: CallbackFlags,
        nonce: u64,
    ) -> Self {
        let order_tag = OrderTag::generate(bond_manager_key.as_ref(), account_key.as_ref(), nonce);
        Self {
            account_key: account_key.to_bytes(),
            user_vault: user_vault.to_bytes(),
            order_tag,
            adapter_account_key: adapter.to_bytes(),
            flags,
            _reserved: [0u8; 14],
        }
    }
}

impl agnostic_orderbook::state::orderbook::CallbackInfo for CallbackInfo {
    type CallbackId = [u8; 16];

    fn as_callback_id(&self) -> &Self::CallbackId {
        self.order_tag.bytes()
    }
}

bitflags! {
    /// Binary flags for the `CallbackInfo`
    #[derive(Zeroable, Pod)]
    #[repr(C)]
    pub struct CallbackFlags: u8 {
        /// any tickets purchased in this order should be automatically staked
        const AUTO_STAKE = 0b00000001;

        /// interest needs to start being accrued because this is new debt
        const NEW_DEBT   = 0b00000010;
    }
}

/// Parameters needed for order placement
#[derive(AnchorDeserialize, AnchorSerialize, Clone, Copy)]
pub struct OrderParams {
    /// The maximum quantity of bond tickets to be traded.
    pub max_bond_ticket_qty: u64,
    /// The maximum quantity of underlying token to be traded.
    pub max_underlying_token_qty: u64,
    /// The limit price of the order. This value is understood as a 32-bit fixed point number.
    pub limit_price: u64,
    /// The maximum number of orderbook postings to match in order to fulfill the order
    pub match_limit: u64,
    /// The order will not be matched against the orderbook and will be direcly written into it.
    ///
    /// The operation will fail if the order's limit_price crosses the spread.
    pub post_only: bool,
    /// Should the unfilled portion of the order be reposted to the orderbook
    pub post_allowed: bool,
    /// Should the purchased tickets be automatically staked with the ticket program
    pub auto_stake: bool,
}

impl OrderParams {
    /// Returns any callback flags that are implied by these parameters
    /// These params do not comprehensively define all flags: there may be other reasons to set flags for an order
    pub fn callback_flags(&self) -> CallbackFlags {
        let mut flags = CallbackFlags::empty();
        flags.set(CallbackFlags::AUTO_STAKE, self.auto_stake);
        flags
    }
}

#[account(zero_copy)]
pub struct EventAdapterMetadata {
    /// Signing authority over this Adapter
    pub owner: Pubkey,
    /// The `BondManager` this adapter belongs to
    pub manager: Pubkey,
    /// The `MarginUser` account this adapter is registered for
    pub orderbook_user: Pubkey,
}

impl EventAdapterMetadata {
    pub const LEN: usize = std::mem::size_of::<Self>();

    pub fn space(num_events: u32) -> usize {
        num_events as usize * (FillEvent::LEN + 2 * CallbackInfo::LEN)
            + Self::LEN
            + EventQueueHeader::LEN
            + 16 // anchor discriminator and agnostic-orderbook tag
    }
}

#[derive(FromPrimitive, Clone, Copy, CheckedBitPattern, NoUninit)]
#[repr(u8)]
pub(crate) enum EventTag {
    Fill,
    Out,
}

pub(crate) type GenericEvent = FillEvent;

pub trait Event {
    fn to_generic(&mut self) -> &GenericEvent;
}

impl Event for FillEvent {
    fn to_generic(&mut self) -> &GenericEvent {
        self.tag = EventTag::Fill as u8;
        self
    }
}

impl Event for OutEvent {
    fn to_generic(&mut self) -> &GenericEvent {
        self.tag = EventTag::Out as u8;
        bytemuck::cast_ref(self)
    }
}

pub enum OrderbookEvent {
    Fill {
        event: FillEvent,
        maker_info: CallbackInfo,
        taker_info: CallbackInfo,
    },
    Out {
        event: OutEvent,
        info: CallbackInfo,
    },
}

#[derive(Clone)]
pub struct EventQueue<'a> {
    data: Rc<RefCell<&'a mut [u8]>>,
    header: EventQueueHeader,
    capacity: usize,
    event_ptr: usize,
    callback_ptr: usize,
    is_adapter: bool,
}

impl<'a> EventQueue<'a> {
    const ADAPTER_OFFSET: usize = EventAdapterMetadata::LEN + 8;

    /// Checks should be done before instanciating an AdapterEventQueue to assert proper ownership
    pub fn from_data(data: Rc<RefCell<&'a mut [u8]>>) -> Result<Self> {
        let buf = &data.borrow();
        let capacity =
            (buf.len() - 8 - EventQueueHeader::LEN) / (FillEvent::LEN + 2 * CallbackInfo::LEN);

        let header_ptr = 8;
        let event_ptr = header_ptr + EventQueueHeader::LEN;
        let callback_ptr = event_ptr + capacity * FillEvent::LEN;

        let header = EventQueueHeader::deserialize(&mut &buf[header_ptr..])?;

        Ok(Self {
            data: data.clone(),
            event_ptr,
            capacity,
            callback_ptr,
            header,
            is_adapter: false,
        })
    }

    pub fn new_adapter(data: Rc<RefCell<&'a mut [u8]>>) -> Result<Self> {
        let buf = &data.borrow();
        let capacity = (buf.len() - 8 - EventQueueHeader::LEN - Self::ADAPTER_OFFSET)
            / (FillEvent::LEN + 2 * CallbackInfo::LEN);

        let header_ptr = 8 + Self::ADAPTER_OFFSET;
        let event_ptr = header_ptr + EventQueueHeader::LEN;
        let callback_ptr = event_ptr + capacity * FillEvent::LEN;

        let header = EventQueueHeader::deserialize(&mut &buf[header_ptr..])?;

        Ok(Self {
            data: data.clone(),
            capacity,
            event_ptr,
            callback_ptr,
            header,
            is_adapter: true,
        })
    }

    /// Pushes the given event to the back of the queue
    pub fn push_event<E: Event>(
        &mut self,
        mut event: E,
        maker_callback_info: Option<&CallbackInfo>,
        taker_callback_info: Option<&CallbackInfo>,
    ) -> std::result::Result<(), Error> {
        let mut buf = self.data.borrow_mut();
        let generic_event = event.to_generic();
        let event_idx = (self.header.head as usize + self.header.count as usize) % self.capacity;

        let events: &mut [FillEvent] =
            bytemuck::cast_slice_mut(&mut buf[self.event_ptr..self.callback_ptr]);
        events[event_idx] = *generic_event;

        self.header.count += 1;

        let callback_infos: &mut [CallbackInfo] =
            bytemuck::cast_slice_mut(&mut buf[self.callback_ptr..]);
        if let Some(c) = maker_callback_info {
            callback_infos[event_idx * 2] = *c;
        }

        if let Some(c) = taker_callback_info {
            callback_infos[event_idx * 2 + 1] = *c;
        }

        Ok(())
    }

    /// Attempts to remove the number of events from the top of the queue
    pub fn pop_events(&mut self, num_events: u32) -> Result<()> {
        let capped_number_of_entries_to_pop = std::cmp::min(self.header.count, num_events as u64);
        self.header.count -= capped_number_of_entries_to_pop;
        self.header.head =
            (self.header.head + capped_number_of_entries_to_pop) % (self.capacity as u64);
        Ok(())
    }

    fn get_event(&self, event_idx: usize) -> OrderbookEvent {
        let buf = self.data.borrow();
        let events: &[FillEvent] = bytemuck::cast_slice(&buf[self.event_ptr..self.callback_ptr]);
        let callback: &[CallbackInfo] = bytemuck::cast_slice(&buf[self.callback_ptr..]);

        let event = &events[event_idx];
        match EventTag::from_u8(event.tag).unwrap() {
            EventTag::Fill => OrderbookEvent::Fill {
                event: *event,
                maker_info: callback[2 * event_idx],
                taker_info: callback[2 * event_idx + 1],
            },
            EventTag::Out => OrderbookEvent::Out {
                event: *bytemuck::cast_ref(event),
                info: callback[2 * event_idx],
            },
        }
    }

    pub fn iter(&self) -> QueueIterator<'a> {
        QueueIterator {
            queue: self.clone(),
            current_index: 0,
            remaining: self.header.count,
        }
    }
}

impl<'a> Drop for EventQueue<'a> {
    fn drop(&mut self) {
        let mut buf = self.data.borrow_mut();

        let offset = match self.is_adapter {
            true => Self::ADAPTER_OFFSET + 8,
            false => 8,
        };
        self.header
            .serialize(&mut (&mut buf[offset..] as &mut [u8]))
            .unwrap();
    }
}

/// Utility struct for iterating over a queue
pub struct QueueIterator<'a> {
    queue: EventQueue<'a>,
    current_index: usize,
    remaining: u64,
}

impl<'a> Iterator for QueueIterator<'a> {
    type Item = OrderbookEvent;

    fn next(&mut self) -> Option<Self::Item> {
        if self.remaining == 0 {
            return None;
        }
        let event_idx =
            (self.queue.header.head as usize + self.current_index) % self.queue.capacity;
        self.current_index += 1;
        self.remaining -= 1;
        Some(self.queue.get_event(event_idx))
    }
}

/// Multiply a `u64` with a fixed point 32 number
/// a is fp0, b is fp32 and result is a*b fp0
pub fn fp32_mul(a: u64, b_fp32: u64) -> Option<u64> {
    (a as u128)
        .checked_mul(b_fp32 as u128)
        .and_then(|e| safe_downcast(e >> 32))
}

/// a is fp0, b is fp32 and result is a/b fp0
pub fn fp32_div(a: u64, b_fp32: u64) -> Option<u64> {
    ((a as u128) << 32)
        .checked_div(b_fp32 as u128)
        .and_then(|x| x.try_into().ok())
}

fn safe_downcast(n: u128) -> Option<u64> {
    static BOUND: u128 = u64::MAX as u128;
    if n > BOUND {
        None
    } else {
        Some(n as u64)
    }
}
