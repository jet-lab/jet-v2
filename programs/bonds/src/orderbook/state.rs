/// Structs and methods related to debts owed by orderbook users
pub mod debt;
/// Structs and methods for deserialization and interaction with the event queue
/// The event queue manages the processing and logic after orders have matched
pub mod event_queue;
/// Structs and methdos for defining and using an `OrderbookUser` account
pub mod user;

use std::convert::TryInto;

use agnostic_orderbook::state::{
    critbit::{InnerNode, LeafNode, SlabHeader},
    event_queue::{EventQueueHeader, FillEvent},
};
use anchor_lang::{prelude::*, solana_program::hash::hash};
use bytemuck::{Pod, Zeroable};
use num_derive::{FromPrimitive, ToPrimitive};

/// The tick_size used in fp32 operations on the orderbook
pub const TICK_SIZE: u64 = 1;
/// The maximum number of events the event queue can support
pub const NUM_EVENTS: u32 = 2_000;
/// Total number of orders that can fit on one side of the orderbook
pub const ORDERBOOK_LEAF_CAPACITY: u32 = 1000;
/// The length in bytes of the `bids` and `asks` bitslabs used in the agnostic orderbook
pub const ORDERBOOK_SLAB_LEN: usize = ORDERBOOK_LEAF_CAPACITY as usize
    * (LeafNode::LEN + CallbackInfo::LEN + InnerNode::LEN)
    + SlabHeader::LEN
    + LeafNode::LEN
    + CallbackInfo::LEN
    + 8;
/// The length in bytes of the `event queue` used to track unconsumed orders on the agnostic orderbook
pub const EVENT_QUEUE_LEN: usize =
    NUM_EVENTS as usize * (FillEvent::LEN + 2 * CallbackInfo::LEN) + EventQueueHeader::LEN + 8;

/// The CallbackInfo is information about an order that is stored in the Event Queue
/// used to manage order metadata
#[derive(Clone, Copy, Debug, PartialEq, Eq, Zeroable, Pod)]
#[repr(C)]
pub struct CallbackInfo {
    /// The Pubkey of the user account that submit the order
    pub orderbook_account_key: [u8; 32],
    /// The order tag is generated by the program when submitting orders to the book
    /// Used to seed and track PDAs such as `Obligation`
    pub order_tag: [u8; 16],
    /// Pubkey of the account that will recieve the event information
    pub adapter_account_key: [u8; 32],
    /// configuration used by callback execution
    pub flags: CallbackFlags,
    _reserved: [u8; 14],
}

impl CallbackInfo {
    pub const LEN: usize = std::mem::size_of::<Self>();
    pub fn new(
        bond_manager_key: Pubkey,
        orderbook_account_key: Pubkey,
        flags: CallbackFlags,
        nonce: u64,
    ) -> Self {
        let order_tag = Self::generate_order_tag(
            bond_manager_key.as_ref(),
            orderbook_account_key.as_ref(),
            nonce,
        );
        Self {
            orderbook_account_key: orderbook_account_key.to_bytes(),
            order_tag,
            adapter_account_key: Pubkey::default().to_bytes(),
            flags,
            _reserved: [0u8; 14],
        }
    }

    pub fn new_with_adapter(
        bond_manager_key: Pubkey,
        orderbook_account_key: Pubkey,
        adapter_account_key: Pubkey,
        flags: CallbackFlags,
        nonce: u64,
    ) -> Self {
        Self {
            orderbook_account_key: orderbook_account_key.to_bytes(),
            order_tag: Self::generate_order_tag(
                bond_manager_key.as_ref(),
                orderbook_account_key.as_ref(),
                nonce,
            ),
            adapter_account_key: adapter_account_key.to_bytes(),
            flags,
            _reserved: [0u8; 14],
        }
    }

    /// To generate an OrderTag, the program takes the sha256 hash of the orderbook user account
    /// and bond manager pubkeys, a nonce tracked by the orderbook user account, and drops the
    /// last 16 bytes to create a 16-byte array
    pub fn generate_order_tag(
        bond_manager_key_bytes: &[u8],
        orderbook_user_key_bytes: &[u8],
        nonce: u64,
    ) -> [u8; 16] {
        let nonce_bytes = bytemuck::bytes_of(&nonce);
        let bytes: &[u8] = &[
            bond_manager_key_bytes,
            orderbook_user_key_bytes,
            nonce_bytes,
        ]
        .concat();
        let hash: [u8; 32] = hash(bytes).to_bytes();
        let tag_bytes: &[u8; 16] = &hash[..16].try_into().unwrap();

        *tag_bytes
    }

    pub fn orderbook_account(&self) -> Pubkey {
        Pubkey::new_from_array(self.orderbook_account_key)
    }
}

impl agnostic_orderbook::state::orderbook::CallbackInfo for CallbackInfo {
    type CallbackId = [u8; 32];

    fn as_callback_id(&self) -> &Self::CallbackId {
        &self.orderbook_account_key
    }
}

bitflags! {
    /// Binary flags for the `CallbackInfo`
    #[derive(Zeroable, Pod)]
    #[repr(C)]
    pub struct CallbackFlags: u8 {
        /// any tickets purchased in this order should be automatically staked
        const AUTO_STAKE = 0b00000001;

        /// interest needs to start being accrued because this is new debt
        const NEW_DEBT   = 0b00000010;
    }
}

/// Is the user placing a `Lend` or `Borrow` order
#[derive(
    AnchorDeserialize, AnchorSerialize, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive,
)]
#[repr(u8)]
pub enum OrderSide {
    Lend,
    Borrow,
}

/// Assets on either side of the orderbook
#[derive(
    AnchorDeserialize, AnchorSerialize, Clone, Copy, PartialEq, Eq, FromPrimitive, ToPrimitive,
)]
#[repr(u8)]
pub enum AssetKind {
    UnderlyingToken,
    BondTicket,
}

/// Parameters needed for order placement
#[derive(AnchorDeserialize, AnchorSerialize, Clone, Copy)]
pub struct OrderParams {
    /// The maximum quantity of bond tickets to be traded.
    pub max_bond_ticket_qty: u64,
    /// The maximum quantity of underlying token to be traded.
    pub max_underlying_token_qty: u64,
    /// The limit price of the order. This value is understood as a 32-bit fixed point number.
    pub limit_price: u64,
    /// The maximum number of orderbook postings to match in order to fulfill the order
    pub match_limit: u64,
    /// The order will not be matched against the orderbook and will be direcly written into it.
    ///
    /// The operation will fail if the order's limit_price crosses the spread.
    pub post_only: bool,
    /// Should the unfilled portion of the order be reposted to the orderbook
    pub post_allowed: bool,
    /// Should the purchased tickets be automatically staked with the ticket program
    pub auto_stake: bool,
}

impl OrderParams {
    /// Returns any callback flags that are implied by these parameters
    /// These params do not comprehensively define all flags: there may be other reasons to set flags for an order
    pub fn callback_flags(&self) -> CallbackFlags {
        let mut flags = CallbackFlags::empty();
        flags.set(CallbackFlags::AUTO_STAKE, self.auto_stake);
        flags
    }
}

/// Multiply a `u64` with a fixed point 32 number
/// a is fp0, b is fp32 and result is a*b fp0
pub fn fp32_mul(a: u64, b_fp32: u64) -> Option<u64> {
    (a as u128)
        .checked_mul(b_fp32 as u128)
        .and_then(|e| safe_downcast(e >> 32))
}

fn safe_downcast(n: u128) -> Option<u64> {
    static BOUND: u128 = u64::MAX as u128;
    if n > BOUND {
        None
    } else {
        Some(n as u64)
    }
}

/// Utility for calculating the limit price from a floating point number
pub fn limit_price_from_f32(f: f32) -> u64 {
    (f * ((1u64 << 32) as f32)) as u64
}
