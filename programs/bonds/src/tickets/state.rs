use anchor_lang::prelude::*;

use crate::{orderbook::state::OrderTag, ErrorCode};

/// A `ClaimTicket` represents a claim of tickets that have been staked with the program
/// This account is generated by the `StakeMarketTickets` program instruction
#[account]
#[derive(Debug)]
pub struct ClaimTicket {
    /// The account registered as owner of this claim
    pub owner: Pubkey,
    /// The `TicketManager` this claim ticket was established under
    /// Determines the asset this ticket will be redeemed for
    pub market_manager: Pubkey,
    /// The slot after which this claim can be redeemed for the underlying value
    pub maturation_timestamp: i64,
    /// The number of tokens this claim  is redeemable for
    pub redeemable: u64,
}

/// A split ticket represents a claim of underlying tokens as the result of a lending action.
///
/// The split ticket is generated when a user places a matched order with the `auto_stake` flag set to true.
/// By taking the difference between the matched base and quote quantities, the split ticket assigns principal and
/// interest values.
#[account]
#[derive(Debug)]
pub struct SplitTicket {
    /// The account registered as owner of this claim
    pub owner: Pubkey,
    /// The `TicketManager` this claim ticket was established under
    /// Determines the asset this ticket will be redeemed for
    pub market_manager: Pubkey,
    /// The `OrderTag` associated with the creation of this struct
    pub order_tag: OrderTag,
    /// The time slot during which the ticket was struck
    pub struck_timestamp: i64,
    /// The slot after which this claim can be redeemed for the underlying value
    pub maturation_timestamp: i64,
    /// The total number of principal tokens the market ticket was struck for
    pub principal: u64,
    /// The total number of interest tokens struck for this market ticket
    /// same underlying asset as the principal token
    pub interest: u64,
}

impl SplitTicket {
    pub fn make_seeds<'a>(user: &'a [u8], bytes: &'a [u8]) -> [&'a [u8]; 3] {
        [crate::seeds::SPLIT_TICKET, user, bytes]
    }
}

/// Enum used for pattern matching a ticket deserialization
pub(crate) enum TicketKind<'info> {
    Claim(Account<'info, ClaimTicket>),
    Split(Account<'info, SplitTicket>),
}

/// Deserializes an ambiguous `AccountInfo` into the correct `TicketKind`
pub(crate) fn deserialize_ticket(info: AccountInfo) -> Result<TicketKind> {
    if let Ok(ticket) = Account::<ClaimTicket>::try_from(&info) {
        return Ok(TicketKind::Claim(ticket));
    } else if let Ok(ticket) = Account::<SplitTicket>::try_from(&info) {
        return Ok(TicketKind::Split(ticket));
    }

    err!(ErrorCode::FailedToDeserializeTicket)
}

make_verification!(ClaimTicket);
make_verification!(SplitTicket);

macro_rules! make_verification {
    ($ticket:ty) => {
        impl $ticket {
            /// Verify ticket ownership, takes owner and manager pubkeys
            pub fn verify_owner_manager(&self, owner: &Pubkey, manager: &Pubkey) -> Result<()> {
                if self.owner != *owner {
                    return err!(ErrorCode::DoesNotOwnTicket);
                }
                if self.market_manager != *manager {
                    return err!(ErrorCode::TicketNotFromManager);
                }

                Ok(())
            }

            /// Verify ticket ownership, takes owner pubkey
            pub fn verify_owner(&self, owner: &Pubkey) -> Result<()> {
                if self.owner != *owner {
                    return err!(ErrorCode::DoesNotOwnTicket);
                }

                Ok(())
            }
        }
    };
}
pub(crate) use make_verification;
