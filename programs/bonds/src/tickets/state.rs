use anchor_lang::prelude::*;
#[cfg(feature = "cli")]
use serde::{ser::SerializeStruct, Serialize, Serializer};

use crate::{orderbook::state::OrderTag, BondsError};

/// A `ClaimTicket` represents a claim of tickets that have been staked with the program
/// This account is generated by the `StakeBondTickets` program instruction
#[account]
#[derive(Debug)]
pub struct ClaimTicket {
    /// The account registered as owner of this claim
    pub owner: Pubkey,
    /// The `TicketManager` this claim ticket was established under
    /// Determines the asset this ticket will be redeemed for
    pub bond_manager: Pubkey,
    /// The slot after which this claim can be redeemed for the underlying value
    pub maturation_timestamp: i64,
    /// The number of tokens this claim  is redeemable for
    pub redeemable: u64,
}

#[cfg(feature = "cli")]
impl Serialize for ClaimTicket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("ClaimTicket", 4)?;
        s.serialize_field("owner", &self.owner.to_string())?;
        s.serialize_field("bondManager", &self.bond_manager.to_string())?;
        s.serialize_field("maturationTimestamp", &self.maturation_timestamp)?;
        s.serialize_field("redeemable", &self.redeemable)?;
        s.end()
    }
}

/// A split ticket represents a claim of underlying tokens as the result of a lending action.
///
/// The split ticket is generated when a user places a matched order with the `auto_stake` flag set to true.
/// By taking the difference between the matched base and quote quantities, the split ticket assigns principal and
/// interest values.
#[account]
#[derive(Debug)]
pub struct SplitTicket {
    /// The account registered as owner of this claim
    pub owner: Pubkey,
    /// The `TicketManager` this claim ticket was established under
    /// Determines the asset this ticket will be redeemed for
    pub bond_manager: Pubkey,
    /// The `OrderTag` associated with the creation of this struct
    pub order_tag: OrderTag,
    /// The time slot during which the ticket was struck
    pub struck_timestamp: i64,
    /// The slot after which this claim can be redeemed for the underlying value
    pub maturation_timestamp: i64,
    /// The total number of principal tokens the bond was struck for
    pub principal: u64,
    /// The total number of interest tokens struck for this bond
    /// same underlying asset as the principal token
    pub interest: u64,
}

impl SplitTicket {
    pub fn make_seeds<'a>(user: &'a [u8], bytes: &'a [u8]) -> [&'a [u8]; 3] {
        [crate::seeds::SPLIT_TICKET, user, bytes]
    }
}

#[cfg(feature = "cli")]
impl Serialize for SplitTicket {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let mut s = serializer.serialize_struct("SplitTicket", 7)?;
        s.serialize_field("owner", &self.owner.to_string())?;
        s.serialize_field("bondManager", &self.bond_manager.to_string())?;
        s.serialize_field("orderTag", &self.order_tag.bytes())?;
        s.serialize_field("struckTimestamp", &self.struck_timestamp)?;
        s.serialize_field("maturationTimestamp", &self.maturation_timestamp)?;
        s.serialize_field("principal", &self.principal)?;
        s.serialize_field("interest", &self.interest)?;
        s.end()
    }
}

/// Enum used for pattern matching a ticket deserialization
pub(crate) enum TicketKind<'info> {
    Claim(Account<'info, ClaimTicket>),
    Split(Account<'info, SplitTicket>),
}

/// Deserializes an ambiguous `AccountInfo` into the correct `TicketKind`
pub(crate) fn deserialize_ticket(info: AccountInfo) -> Result<TicketKind> {
    if let Ok(ticket) = Account::<ClaimTicket>::try_from(&info) {
        return Ok(TicketKind::Claim(ticket));
    } else if let Ok(ticket) = Account::<SplitTicket>::try_from(&info) {
        return Ok(TicketKind::Split(ticket));
    }

    err!(BondsError::FailedToDeserializeTicket)
}

make_verification!(ClaimTicket);
make_verification!(SplitTicket);

macro_rules! make_verification {
    ($ticket:ty) => {
        impl $ticket {
            /// Verify ticket ownership, takes owner and manager pubkeys
            pub fn verify_owner_manager(&self, owner: &Pubkey, manager: &Pubkey) -> Result<()> {
                if self.owner != *owner {
                    return err!(BondsError::DoesNotOwnTicket);
                }
                if self.bond_manager != *manager {
                    return err!(BondsError::TicketNotFromManager);
                }

                Ok(())
            }

            /// Verify ticket ownership, takes owner pubkey
            pub fn verify_owner(&self, owner: &Pubkey) -> Result<()> {
                if self.owner != *owner {
                    return err!(BondsError::DoesNotOwnTicket);
                }

                Ok(())
            }
        }
    };
}
pub(crate) use make_verification;
